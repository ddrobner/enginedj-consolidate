# this script takes the energy IDv3 tag from the file and copies it to the rating
# NOTE: There will probably be some caveats here - like what the scale of the energy tag in your library is
# Mine are all generated by mixed in key, so they are out of 10, but YMMV

import taglib
import argparse
import sqlite3
from os import chdir
from pathlib import Path

from engineutils.track import Track

parser = argparse.ArgumentParser(
    prog = "Energy to Rating",
    description = "Converted IDv3 energy tags to ratings in Engine DJ Database"
)


parser.add_argument('engine_library_path', help="Path to Engine Library (the folder where 'm.db' is)")

args = parser.parse_args()

chdir(args.engine_library_path)

# setting up DB con
db_con = sqlite3.connect(Path("Database2/m.db"))
cursor = db_con.cursor()
cursor.execute("SELECT id, path FROM Track ORDER BY id ASC;")

# load tracks into a format we can work with
tracks = []

# fetching the tracks in the db
for t in cursor.fetchall():
    tracks.append(Track(t[0], t[1]))

# now we read the energy from the actual files
for t in tracks:
    # here, we convert the number used to store energy to the way engine dj
    # stores it in it's database (0-100 in increments of 20, for each star)
    try:
        with taglib.File(t.path) as s:
            energy = int(s.tags['ENERGYLEVEL'][0])
            # have to round here since engine doesn't support half stars
            # IMO I can change this later since the mp3 tag is the authoritative
            # source of information and I'd rather not have the engine db be
            # unhappy :)
            t.energy = 10*(energy if energy % 2 == 0 else (energy + 1))
            cursor.execute(f'UPDATE Track SET rating = {t.energy} WHERE id = {t.id}')
    except:
        # if that doesn't work we don't touch the DB
        pass

db_con.commit()
db_con.close()
print("All done :-)")